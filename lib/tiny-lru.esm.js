class t{constructor(t=0,i=0){this.first=null,this.items={},this.last=null,this.max=t,this.size=0,this.ttl=i}has(t){return t in this.items}clear(){return this.first=null,this.items={},this.last=null,this.size=0,this}delete(t){if(this.has(t)){const i=this.items[t];delete this.items[t],this.size--,null!==i.prev&&(i.prev.next=i.next),null!==i.next&&(i.next.prev=i.prev),this.first===i&&(this.first=i.next),this.last===i&&(this.last=i.prev)}return this}evict(){const t=this.first;return delete this.items[t.key],this.first=t.next,this.first.prev=null,this.size--,this}get(t){let i;if(this.has(t)){const s=this.items[t];this.ttl>0&&s.expiry<=(new Date).getTime()?this.delete(t):(i=s.value,this.set(t,i,!0))}return i}keys(){return Object.keys(this.items)}set(t,i,s=!1){let h;if(s||this.has(t)){if((h=this.items[t]).value=i,this.last!==h){const t=this.last,i=h.next,s=h.prev;this.first===h&&(this.first=h.next),h.next=null,h.prev=this.last,t.next=h,null!==s&&(s.next=i),null!==i&&(i.prev=s)}}else this.max>0&&this.size===this.max&&this.evict(),h=this.items[t]={expiry:this.ttl>0?(new Date).getTime()+this.ttl:this.ttl,key:t,prev:this.last,next:null,value:i},1==++this.size?this.first=h:this.last.next=h;return this.last=h,this}}export default function(i=1e3,s=0){if(isNaN(i)||i<0)throw new TypeError("Invalid max value");if(isNaN(s)||s<0)throw new TypeError("Invalid ttl value");return new t(i,s)}
